## 是什么

JavaScript 是单线程的，事件循环允许 Node.js 执行非阻塞的 I/O 操作。

由于大多数现代内核是多线程的，它们可在后台执行的多个操作。当其中一个操作完成时，内核会告诉 Node.js ，以便适当的回调可以添加到最终要执行的轮询队列中。

## 解释

当 Node.js 启动时，它初始化事件循环，处理输入脚本，脚本可能进行异步API调用，调度计时器，或调用 `process.nextTick()` ，然后开始处理事件循环。

```shell
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

每个阶段都有一个 FIFO 回调队列要执行。虽然每个阶段都有自己的特殊之处，但通常情况下，当事件循环进入一个给定阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列已用完或执行了最大数量的回调。当队列已耗尽或达到回调限制时，事件循环将移动到下一阶段，依此类推。

由于这些操作中的任何一个都可能调度更多的操作，并且在轮询阶段处理的新事件由内核加入队列，所以轮询事件也可以在轮询事件被处理时被加入队列。因此，长时间运行的回调会导致轮询阶段运行的时间比计时器的阈值长得多。

### 阶段总览

- timers：此阶段执行 `setTimeout()` 和 `setInterval()` 的回调

- pending callbacks：执行延迟到下一个循环迭代的 I/O 回调

- idle, prepare：内部使用

- poll：
  - 检索新的 I/O 事件
  - 执行与 I/O 相关的回调(几乎除了close回调、由计时器调度的回调和setimmediation()之外的所有回调)
  - 节点将在适当的时候在这里阻塞

- check：`setimmediation()` 回调在这里被调用

- close callbacks：一些 close 回调，例如 `socket.on('close', ...)`

## 阶段详情

### timers

计时器回调将尽可能早地运行，但是操作系统调度或其他回调的运行可能会延迟它们。

注意:技术上，轮询阶段控制计时器何时执行。

例如，假设你在100毫秒后执行一个回调，然后你的脚本开始异步读取一个需要95毫秒的文件。当进入 poll 阶段时是一个空队列（`fs.readFile()` 还没有完成），所以会等待几毫秒，直到最快的定时器到期。

当它等待95毫秒时，`fs.readFile()` 完成了文件的读取，它的回调(需要10毫秒才能完成)被添加到轮询队列并执行。

当回调结束时，队列中不再有回调，因此事件循环将看到最快计时器的阈值已经达到，然后返回到计时器阶段来执行计时器的回调。

注意：为了防止轮询阶段阻塞事件循环，libuv 也有一个轮询更多事件最大值(依赖于系统)。

### pending callbacks

这个阶段执行一些系统操作的回调。

### poll

轮询阶段有两个主要功能:

- 计算它应该阻塞多长时间并轮询 I/O

- 处理轮询队列中的事件

当事件循环进入轮询阶段且没有计时器调度时，将发生以下两种情况之一：

- 如果轮询队列不是空的，则事件循环将遍历其回调队列，以同步方式执行回调，直到队列耗尽或达到系统相关的硬限制为止
- 如果轮询队列为空，将发生以下两种情况之一：
  - 如果有 `setimmediation()` ，则事件循环将结束轮询阶段，并继续到 check 阶段执行这些调度脚本
  - 如果没有 `setimmediation()` ，事件循环将等待回调被添加到队列中，然后立即执行它们

一旦轮询队列为空，事件循环将检查达到时间阈值的计时器。如果一个或多个计时器准备好了，事件循环将返回到计时器阶段，以执行这些计时器的回调。

### check

`setimmediation()` 实际上是一个特殊的计时器，运行在事件循环的单独阶段。它使用一个libuv API来调度回调，以便在轮询阶段完成后执行。

通常在执行代码时，事件循环最终会到达 poll 阶段，在此阶段它将等待传入的连接、请求等。但是，如果已经用 `setimmediation()` 调度了回调，并且轮询阶段变为空闲状态，那么它将结束并继续 check 阶段，而不是等待轮询事件。

### close callbacks

如果套接字或句柄突然关闭(例如socket.destroy())，那么“close”事件将在此阶段发出。

## `setImmediate()` vs `setTimeout()`

setimmediation()和setTimeout()是相似的，但是根据它们被调用的时间不同，它们的行为方式不同。

- setImmediate() 用于在当前轮询阶段完成后执行脚本

- setTimeout() 在超过最小阈值后运行脚本

计时器执行的顺序取决于调用它们的上下文。如果从主模块内部同时调用这两种方法，则计时将受到进程性能的约束。

## `process.nextTick()` vs `setImmediate()`

就用户而言，我们有两个类似的调用，但它们的名称令人困惑。

- process.nextTick() 立即在同一阶段触发

- setImmediate() 在接下来的循环或 tick 触发

## Why use process.nextTick()?

以下是两个主要原因:

- 允许用户处理错误，清除不需要的资源，或者在事件循环继续之前再次尝试请求。

- 有时，有必要允许在调用堆栈解压缩之后、事件循环继续之前运行回调。

