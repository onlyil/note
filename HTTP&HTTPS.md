## HTTP

- 用于客户端和 服务器之间的通信。属于网络模型中的应用层
- 无状态
- 使用方法下达命令
- 持久连接节省通信量

### 三次握手

- 客户端首先发送一个带有SYN标志的数据包给服务端（syn_sent）
- 服务端接受SYN数据包之后，回传一个SYN/ACK标志的数据包以示传达确认连接信息（syn_rcvd）
- 客户端收到SYN/ACK的确认数据包之后，再回传一个ACK标志的数据包给服务端，表示‘握手’结束（established）

### 四次挥手

- 客户端向服务端先发送一个带有FIN标志的数据包给服务端（fin_wait_1）
- 服务端接受FIN数据包之后，回传一个ACK的数据包给客户端以示传达确认关闭信息（close_wait）
- 服务端向客户端发送一个FIN标志的数据包，请求关闭连接（last_ack）
- 客户端收到FIN的数据包之后，回传一个ACK的数据包给服务端，以表示确认关闭

## HTTP 问题

- 通信使用明文，可能被窃听；
- 不验证通信方的身份，可能遭遇伪装；
- 无法证明报文的完整性，有可能遭遇篡改。

## 加密通信过程

1. 浏览器生成随机串A作为通信密钥；
2. 浏览器使用公钥将随机串A加密后得到密文B发送给服务器，这一步是安全的，因为黑客没有服务端私钥无法解密；
3. 服务端利用私钥解密出随机串A得到通信密钥；
4. 服务端和客户端用随机串A以及对称加密算法进行通信。

但是浏览器是如何得到公钥的?

- 浏览器内置(不太可能，网站域名这么多，浏览器内置这么多公钥不现实)；
- 服务器给浏览器下发(由于是明文下发，存在被窃听和篡改风险，也就是著名的中间人攻击)。

## 中间人攻击

1. 浏览器请求服务器获取公钥；
2. 中间人劫持了服务器的公钥，保存在自己手里；
3. 中间人生成一对密钥对，把伪造的公钥下发给浏览器；
4. 浏览器使用伪造的公钥和中间人通信；
5. 中间人和服务器进行通信。

只要保证浏览器得到的公钥是目标网站的公钥即可保证通信安全，那么问题来了，如何在不可靠的网络上安全的传输公钥呢?

## TLS/SSL工作原理

### 散列函数

常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性。

### 对称加密

常见的有AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1。

### 非对称加密

即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。

## HTTPS

### CA

数字证书签发机构，CA 负责核实公钥的拥有者的信息，并颁发认证"证书"，同时能够为使用者提供证书验证服务。

### 数字证书

包含签发机构、有效期、申请人公钥、证书所有者、证书签名算法、证书指纹以及指纹算法等信息。

### 数字签名

使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名。

### 证书签发过程

1. 网站生成密钥对，将私钥自己保存，公钥和网站域名等信息提交给CA；
2. CA把证书签发机构(也就是自己)、证书有效期、网站的公钥、网站域名等信息以**明文**形式写入到一个文本文件；
3. CA选择一个散列函数计算文本文件的内容得到**指纹**(信息摘要)，用CA的**私钥**对**指纹**和散列函数进行加密得到**数字签名**，签名算法包含在证书的**明文**部分
4. CA把明文证书、指纹、指纹算法、数字签名等信息打包在一起得到证书下发给服务器

### 证书验证过程

1. 浏览器以HTTPS协议请求服务器的443端口；
2. 服务器下发自己的数字证书给浏览器(明文)；
3. 客户端先校验CA、有效期、域名是否有效，如果无效，则终止连接(服务器此时不可信任)；
4. 客户端读取证书中的相关的明文信息，采用相同的散列函数计算得到**指纹**(信息摘要)，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法；

![NlIoSH.png](https://s1.ax1x.com/2020/06/20/NlIoSH.png)

浏览器通过操作系统内置权威CA公钥的方式解决了网站公钥下发问题。