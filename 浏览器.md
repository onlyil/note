## 导航流程

### 1. 用户输入

- 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL；
- 如果判断输入内容符合URL规则，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL。

当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时页面显示的依然是之前打开的页面内容，因为需要等待提交文档阶段，页面内容才会被替换。

### 2. URL请求过程

浏览器进程会通过进程间通信（IPC）把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。

- 本地缓存
- DNS解析
- TCP连接
- 发送请求
- 处理响应
  - 重定向：网络进程开始解析响应头，如果发现返回的状态码是301或者302，那么说明服务器需要浏览器重定向到其他URL；
  - 响应数据类型处理：不同Content-Type的后续处理流程也截然不同。如果Content-Type字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该URL请求的导航流程就此结束。但如果是HTML，那么浏览器则会继续进行导航流程。

### 3. 准备渲染进程

- 通常情况下，打开新的页面都会使用单独的渲染进程；
- 如果从A页面打开B页面，且A和B都属于同一站点的话，那么B页面复用A页面的渲染进程。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

### 4. 提交文档

这里的“文档”是指URL请求的响应体数据。

- “提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
- 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
- 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。

## 渲染流程

### 1. 构建 DOM 树（ParseHTML）

- 构建DOM树的输入内容是一个非常简单的 HTML 文件，然后经由HTML解析器解析，最终输出树状结构的 DOM；
- 这个过程会同时发起外部资源（css、js）的请求。

### 2. 样式计算

- **Parse Stylesheet**：把CSS转换为浏览器能够理解的结构（document.styleSheets）；
- 转换样式表中的属性值，使其标准化；
- **Recalculate Style**：计算出DOM树中每个节点的具体样式（继承规则和层叠规则）。

### 3. 布局（Layout）

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出DOM树中可见元素的几何位置，我们把这个计算过程叫做布局。

- 创建布局树
  - 遍历DOM树中的所有可见节点，并把这些节点加到布局中；
  - 而不可见的节点会被布局树忽略掉，如`head`标签下面的全部内容、dispaly: none
- 布局计算，计算节点的坐标位置

### 4. 分层（Update Layer Tree）

因为页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

- **第一点，拥有层叠上下文属性的元素会被提升为单独的一层；**
- **第二点，需要剪裁（clip）的地方也会被创建为图层。**

### 5. 绘制（Paint）

渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

### 6. 合成（Composite Layers）

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。

- 栅格化（raster）操作：渲染进程把生成图块的指令发送给GPU，然后在GPU中执行生成图块的位图，并保存在GPU的内存中；
- 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

![浏览器 Event Log](https://s1.ax1x.com/2020/06/17/NVavdA.png)

## 相关

### 更新了元素的几何属性（重排）

通过JavaScript或者CSS修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

### 更新元素的绘制属性（重绘）

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。**相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些**。

### 直接合成

使用了 CSS 的 transform 来实现动画效果，这可以避开布局和绘制阶段，直接在非主线程上执行合成动画操作，这样的效率是最高的。

